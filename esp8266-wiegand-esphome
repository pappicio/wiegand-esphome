esphome:
  name: "apriporte-wiegand"
  friendly_name: apriporte-wiegand
 
################################################################
preferences:
  flash_write_interval: 1sec
################################################################

#esp32:
#  board: esp32-c3-devkitm-1
#  framework:
#    type: arduino
  
esp8266:
  board: esp01_1m
  restore_from_flash: true

 

 
logger:
  level: debug
  logs:
    text_sensor: error
    number: ERROR
    sensor: ERROR
    ultrasonic.sensor: ERROR

# Enable Home Assistant API
api:

##############################################################
# Allow Over-The-Air updates
ota:
  - platform: esphome
    password: !secret ota_password
##############################################################
# Allow provisioning Wi-Fi via serial
improv_serial:

wifi:
  networks:
    - ssid: peppe4
    - password: !secret wifi_password4
    - ssid: peppe2
    - password: !secret wifi_password2
    - ssid: peppe6
    - password: !secret wifi_password6
  manual_ip:
    static_ip: 192.168.1.79
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 192.168.1.1

  ap:
    {}

captive_portal:
 
#########################################################################
#########################################################################
web_server:
  version: 3
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
#########################################################################
#########################################################################

#########################################################################
text_sensor:
  - platform: wifi_info
    ssid:
      name: "wifi connesso a:"
      web_server:
        sorting_weight: 70
      
  - platform: template
    name: "Uptime:"
    web_server:
      sorting_weight: 81
    lambda: |-
      int seconds = (id(uptimex).state);
      String days = String(seconds / (24 * 3600));
      //if (days.length() == 1)
      //{
      //days="0" + days;
      //}
      seconds = seconds % (24 * 3600); 
      String hours = String(seconds / 3600);
      if (hours.length() == 1)
      {
      hours="0" + hours;
      }
      seconds = seconds % 3600;
      String minutes = String(seconds /  60);
      if (minutes.length() == 1)
      {
      minutes="0" + minutes;
      }
      String second = String(seconds % 60);
      if (second.length() == 1)
      {
      second="0" + second;
      }
      return { (days +" g; " + hours +" h " + minutes +" m e "+ second +" s").c_str() };
      //return { (String(days) +"g " + String(hours) +"h:" + String(minutes) +"m:"+ String(seconds) +"s").c_str() };
 
    icon: mdi:clock-start
    update_interval: 5s

  - platform: template
    name: "Badge Autorizzati"
    id: homeassistant_tag_scanned
    icon: mdi:badge-account
    web_server:
      sorting_weight: 20

  - platform: template
    name: "Password autorizzate"
    id: keypad_codes_sensor
    web_server:
      sorting_weight: 21
    lambda: |-
      std::string result;
      for (const auto& code : id(keypad_code_history)) {
          result += code + ", \n";
      }
      if (!result.empty()) {
          result.pop_back();
          result.pop_back();
      }
      return { result.c_str() };
    update_interval: 5s
    icon: mdi:form-textbox-password

  - platform: template
    name: "Impronte autorizzate"
    web_server:
      sorting_weight: 22
    id: fingerprint_scanned_sensor
    lambda: |-
      std::string result;
      for (const auto& print : id(fingerprint_history)) {
          result += print + ", \n";
      }
      if (!result.empty()) {
          result.pop_back();
          result.pop_back();
      }
      return { result.c_str() };
    update_interval: 5s
    icon: mdi:fingerprint
 


  # Text sensor per le password non autorizzate
  - platform: template
    name: "Password Non Autorizzate"
    web_server:
      sorting_weight: 23
    id: unauthorized_keypad_codes_sensor
    lambda: |-
      std::string result;
      for (const auto& code : id(unauthorized_keypad_codes)) {
          result += code + ", \n";
      }
      if (!result.empty()) {
          result.pop_back();
          result.pop_back();
      }
      return { result.c_str() };
    update_interval: 5s
    icon: mdi:form-textbox-password

  # Text sensor per i badge non autorizzati
  - platform: template
    name: "Badge o impronte non autorizzati"
    web_server:
      sorting_weight: 24
    id: unauthorized_tags_sensor
    lambda: |-
      std::string result;
      for (const auto& tag : id(unauthorized_tags)) {
          result += tag + ", \n";
      }
      if (!result.empty()) {
          result.pop_back();
          result.pop_back();
      }
      return { result.c_str() };
    update_interval: 5s
    icon: mdi:account-off



  - platform: template
    name: "Ultima Password non valida"
    id: last_unauthorized_keypad_code_sensor
    update_interval: never
    web_server:
      sorting_weight: 50

  - platform: template
    name: "Ultimo TAG o Impronta non valido"
    id: last_unauthorized_tag_code_sensor
    update_interval: never
    web_server:
      sorting_weight: 51
#########################################################################
sensor:
  - platform: wifi_signal
    name: "Segnale WiFi"
    web_server:
      sorting_weight: 80
    update_interval: 10s

  - platform: uptime
    name: "Uptime"
    internal: true
    id: uptimex
    update_interval: 5s
# Usa un output GPIO con id "led_builtin"
 


globals:

  - id: codice_valido
    type: bool
    initial_value: 'false'  # Inizialmente il codice non è valido


  - id: last_formatted_code
    type: std::string
    initial_value: ""


  - id: fingerprint_history
    type: std::vector<std::string>
    initial_value: ""

  - id: keypad_code_history
    type: std::vector<std::string>
    initial_value: ""
  
  - id: tag_history
    type: std::vector<std::string>
    initial_value: ""
 

  # Aggiunta lista di password non autorizzate
  - id: unauthorized_keypad_codes
    type: std::vector<std::string>
    initial_value: ""

  # Aggiunta lista di badge non autorizzati
  - id: unauthorized_tags
    type: std::vector<std::string>
    initial_value: ""
    
  

  - id: authorized_keypad_codes_12
    type: std::vector<std::string>
    initial_value: '{"19755791"}'

  - id: authorized_keypad_codes_1
    type: std::vector<std::string>
    initial_value: '{"0"}'

  - id: authorized_keypad_codes_2
    type: std::vector<std::string>
    initial_value: '{"0"}'

  - id: authorized_fingerprint
    type: std::vector<uint64_t>  # Ora il tipo è corretto
                     #impronte mie                            #impronte 1                       #impronte 2
    initial_value: '{111111,222222,444444,555555, 666666,777777,888888,999999}' 
  
  - id: authorized_tags_12
    type: std::vector<uint64_t>  # Ora il tipo è corretto
                    #M1      #2   #3 #Tessera xxx
    initial_value: '{121212121, 34343434, 4545455,56565656}'  # I badge devono essere numeri

  - id: authorized_tags_1
    type: std::vector<uint64_t>  # Ora il tipo è corretto
    initial_value: '{0}'  # I badge devono essere numeri
  
  - id: authorized_tags_2
    type: std::vector<uint64_t>  # Ora il tipo è corretto
    initial_value: '{0}'  # I badge devono essere numeri
 
  - id: last_tag
    type: uint64_t
    restore_value: True
    initial_value: '0'  # L'ultimo tag letto sarà un numero
 
  - id: led_state
    type: bool
    restore_value: no
    initial_value: 'false'

output:
  - platform: gpio
    pin:
      number: GPIO2
      inverted: true
    id: led_builtin  # ID dell'output come richiesto


interval:
  - interval: 1s
    then:
      - lambda: |-
          id(led_state) = !id(led_state);
          if (id(led_state)) {
            id(led_builtin).turn_on();
          } else {
            id(led_builtin).turn_off();
          }


switch:
  - platform: template
    internal: false
    restore_mode: ALWAYS_OFF 
    name: "portone cancello"
    icon: mdi:door
    web_server:
      sorting_weight: 10
    id: portone_cancello
    optimistic: true
    lambda: return id(portone_cancello).state;  
    on_turn_on: 
      then:
        - delay: 4s
        - switch.turn_off: portone_cancello


  - platform: template
    internal: false
    restore_mode: ALWAYS_OFF
    name: "spesa da prendere"
    icon: "mdi:shopping-cart"
    web_server:
      sorting_weight: 9
    id: spesa_da_prendere
    optimistic: true
    lambda: return id(spesa_da_prendere).state;  
    on_turn_on: 
      then:
        - delay: 1s
        - switch.turn_off: spesa_da_prendere


  - platform: gpio
    id: relay1
    pin: 
      number: GPIO4
      inverted: true
      mode: 
        output: True
        open_drain: True
    restore_mode: ALWAYS_OFF
    name: "Apri Portone"
    web_server:
      sorting_weight: 2
    icon: mdi:garage-open
    on_turn_on:
      - delay: 1000ms
      - switch.turn_off: relay1  # Spegne il relè dopo 1000ms

  - platform: gpio
    id: relay2
    pin: 
      number: GPIO5
      inverted: true
      mode: 
        output: True
        open_drain: True
    restore_mode: ALWAYS_OFF
    name: "Apri Cancello"
    web_server:
      sorting_weight: 3
    icon: mdi:gate
    on_turn_on:
      - delay: 1000ms
      - switch.turn_off: relay2  # Spegne il relè dopo 1000ms


  - platform: template
    id: tag_scan_enabled
    name: "Abilita Tastiera"
    web_server:
      sorting_weight: 1
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:keyboard

  - platform: template
    id: clear_history_button
    name: "Cancella Storico"
    web_server:
      sorting_weight: 11
    icon: mdi:history
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(unauthorized_tags).clear();
          id(unauthorized_keypad_codes).clear();
          id(tag_history).clear();
          id(fingerprint_history).clear();
          id(keypad_code_history).clear();
          id(homeassistant_tag_scanned).publish_state("Storico cancellato");
          id(last_unauthorized_keypad_code_sensor).publish_state("unknown");
          id(last_unauthorized_tag_code_sensor).publish_state("unknown");
          
      - delay: 500ms
      - switch.turn_off: clear_history_button

# Example configuration entry
key_collector:
  - id: pincode_reader
    source_id: mykeypad
    min_length: 6
    max_length: 9
    end_keys: "#"
    end_key_required: true
    clear_keys: "*"
    allowed_keys: "0123456789"
    timeout: 5s
    on_result:
      - if:
          condition:
            switch.is_on: tag_scan_enabled
          then:
            - lambda: |-

                std::string code = x;
                id(last_formatted_code) = code;

                bool codice_validox = false;

                // tastiera12
                for (const auto& c : id(authorized_keypad_codes_12)) {
                    if (c == code) {
                        codice_validox = true;
                        ESP_LOGI("ACCESSO", "%s Password VALIDA (relay 12)", code.c_str());
                        id(accensione_relay12)->execute();
                        break;
                    }
                }
                // tastiera1
                if (!codice_validox) {
                    for (const auto& c : id(authorized_keypad_codes_1)) {
                        if (c == code) {
                            codice_validox = true;
                            ESP_LOGI("ACCESSO", "%s Password VALIDA (relay 1)", code.c_str());
                            id(accensione_relay1)->execute();
                            break;
                        }
                    }
                }
                // tastiera2
                if (!codice_validox) {
                    for (const auto& c : id(authorized_keypad_codes_2)) {
                        if (c == code) {
                            codice_validox = true;
                            ESP_LOGI("ACCESSO", "%s Password VALIDA (relay 2)", code.c_str());
                            id(accensione_relay2)->execute();
                            break;
                        }
                    }
                }

                if (codice_validox){
                  id(keypad_code_history).push_back(x);
                  if (id(keypad_code_history).size() > 24) {
                      id(keypad_code_history).erase(id(keypad_code_history).begin());
                  }

                  std::string codes_concatenati;
                  for (const auto& tag : id(keypad_code_history)) {
                      codes_concatenati += tag + ", \n";
                  }
                  if (!codes_concatenati.empty()) {
                      codes_concatenati.pop_back();
                      codes_concatenati.pop_back();
                  }

                  id(keypad_codes_sensor).publish_state(codes_concatenati);
                }
                // Codice non autorizzato
                if (!codice_validox) {
                    ESP_LOGW("ACCESSO", "%s Password NON valida", code.c_str());

                    // Aggiungi alla lista di password non autorizzate
                    id(unauthorized_keypad_codes).push_back(code);
                    if (id(unauthorized_keypad_codes).size() > 24) {
                        id(unauthorized_keypad_codes).erase(id(unauthorized_keypad_codes).begin());
                    }

                    std::string unauthorized_codes_concatenati;
                    for (const auto& code : id(unauthorized_keypad_codes)) {
                        unauthorized_codes_concatenati += code + ", \n";
                    }
                    if (!unauthorized_codes_concatenati.empty()) {
                        unauthorized_codes_concatenati.pop_back();
                        unauthorized_codes_concatenati.pop_back();
                    }

                    id(unauthorized_keypad_codes_sensor)->publish_state(unauthorized_codes_concatenati);
                    // 🔔 Pubblica anche l'ultimo codice non autorizzato in un sensore separato
                    id(last_unauthorized_keypad_code_sensor).publish_state("unknown");
                    id(last_unauthorized_keypad_code_sensor).publish_state(code);
                     
                }

            - homeassistant.tag_scanned: !lambda 'return id(last_formatted_code);'

                
#on_raw:
wiegand:
  - id: mykeypad
    d0: GPIO13
    d1: GPIO12

    #on_key:
      #- lambda: |-
      #    ESP_LOGI("KEY", "received key %d", x);

    on_tag:
     - if:
        condition:
            switch.is_on: tag_scan_enabled
        then:
            - lambda: |-
                uint64_t received_tag = std::stoull(x.c_str());
                bool access_granted = false;
                bool is_fingerprint = false;  // Nuova variabile per distinguere impronta da tag

                // === IMPRONTA ===
                for (const auto& tag : id(authorized_fingerprint)) {
                    if (tag == received_tag) {
                        ESP_LOGI("ACCESSO", "%s Impronta VALIDa", x.c_str());
                        id(accensione_relay12)->execute();
                        access_granted = true;
                        is_fingerprint = true;

                        // Storico impronte
                        id(fingerprint_history).push_back(x);
                        if (id(fingerprint_history).size() > 24) {
                            id(fingerprint_history).erase(id(fingerprint_history).begin());
                        }

                        std::string prints_concatenati;
                        for (const auto& print : id(fingerprint_history)) {
                            prints_concatenati += print + ", \n";
                        }
                        if (!prints_concatenati.empty()) {
                            prints_concatenati.pop_back();
                            prints_concatenati.pop_back();
                        }

                        id(fingerprint_scanned_sensor)->publish_state(prints_concatenati);
                        break;
                    }
                }

                // === BADGE 12 ===
                if (!access_granted && !is_fingerprint) {
                    for (const auto& tag : id(authorized_tags_12)) {
                        if (tag == received_tag) {
                            ESP_LOGI("ACCESSO", "%s Badge 12 VALIDO!", x.c_str());
                            id(accensione_relay12)->execute();
                            access_granted = true;

                            id(tag_history).push_back(x);
                            if (id(tag_history).size() > 24) {
                                id(tag_history).erase(id(tag_history).begin());
                            }

                            std::string tags_concatenati;
                            for (const auto& tag : id(tag_history)) {
                                tags_concatenati += tag + ", \n";
                            }
                            if (!tags_concatenati.empty()) {
                                tags_concatenati.pop_back();
                                tags_concatenati.pop_back();
                            }

                            id(homeassistant_tag_scanned)->publish_state(tags_concatenati);
                            break;
                        }
                    }
                }

                // === BADGE 1 ===
                if (!access_granted && !is_fingerprint) {
                    for (const auto& tag : id(authorized_tags_1)) {
                        if (tag == received_tag) {
                            ESP_LOGI("ACCESSO", "%s Badge 1 VALIDO!", x.c_str());
                            id(accensione_relay1)->execute();
                            access_granted = true;

                            id(tag_history).push_back(x);
                            if (id(tag_history).size() > 24) {
                                id(tag_history).erase(id(tag_history).begin());
                            }

                            std::string tags_concatenati;
                            for (const auto& tag : id(tag_history)) {
                                tags_concatenati += tag + ", \n";
                            }
                            if (!tags_concatenati.empty()) {
                                tags_concatenati.pop_back();
                                tags_concatenati.pop_back();
                            }

                            id(homeassistant_tag_scanned)->publish_state(tags_concatenati);
                            break;
                        }
                    }
                }

                // === BADGE 2 ===
                if (!access_granted && !is_fingerprint) {
                    for (const auto& tag : id(authorized_tags_2)) {
                        if (tag == received_tag) {
                            ESP_LOGI("ACCESSO", "%s Badge 2 VALIDO!", x.c_str());
                            id(accensione_relay2)->execute();
                            access_granted = true;

                            id(tag_history).push_back(x);
                            if (id(tag_history).size() > 24) {
                                id(tag_history).erase(id(tag_history).begin());
                            }

                            std::string tags_concatenati;
                            for (const auto& tag : id(tag_history)) {
                                tags_concatenati += tag + ", \n";
                            }
                            if (!tags_concatenati.empty()) {
                                tags_concatenati.pop_back();
                                tags_concatenati.pop_back();
                            }

                            id(homeassistant_tag_scanned)->publish_state(tags_concatenati);
                            break;
                        }
                    }
                }

                // === NESSUN ACCESSO ===
                if (!access_granted && !is_fingerprint) {
                    ESP_LOGI("ACCESSO", "s% Badge o Impronta NON autorizzato!", x.c_str());

                    id(unauthorized_tags).push_back(x);
                    if (id(unauthorized_tags).size() > 24) {
                        id(unauthorized_tags).erase(id(unauthorized_tags).begin());
                    }

                    std::string unauthorized_tags_concatenati;
                    for (const auto& tag : id(unauthorized_tags)) {
                        unauthorized_tags_concatenati += tag + ", \n";
                    }
                    if (!unauthorized_tags_concatenati.empty()) {
                        unauthorized_tags_concatenati.pop_back();
                        unauthorized_tags_concatenati.pop_back();
                    }

                    id(unauthorized_tags_sensor)->publish_state(unauthorized_tags_concatenati);
                    // 🔔 Pubblica anche l'ultimo tag o impronta non autorizzato in un sensore separato
                    id(last_unauthorized_tag_code_sensor).publish_state("unknown");
                    id(last_unauthorized_tag_code_sensor).publish_state(x.c_str());
                   
                }

            - homeassistant.tag_scanned: !lambda 'return x.c_str();'
        else:
            - lambda: |-
                ESP_LOGI("TAG", "Tastiera DISABILITATA");

script:
  - id: accensione_relay12
    then:
      - switch.turn_on: relay2
      - delay: 2000ms
      - switch.turn_on: relay1

  - id: accensione_relay1
    then:
      - switch.turn_on: relay1


  - id: accensione_relay2
    then:
      - switch.turn_on: relay2
     
