

esphome:
  name: apriporte-wiegand
  friendly_name: apriporte wiegand
  name_add_mac_suffix: false
  on_boot:
    priority: 600
    then:
      - script.execute: restore_all
################################################################
esp32:
  board: lolin_s2_mini
  variant: ESP32S2
  framework:
    type: arduino


################################################################
preferences:
  flash_write_interval: 1sec
################################################################
 
logger:
  level: debug  #INFO
  logs:
    text_sensor: error
    number: ERROR
    sensor: ERROR
    sntp: NONE  # Impedisce che i log di sincronizzazione SNTP vengano visualizzati
    #wiegand: WARN


# Enable Home Assistant API
api:

##############################################################
# Allow Over-The-Air updates
ota:
  - platform: esphome
    password: !secret ota_password
##############################################################
# Allow provisioning Wi-Fi via serial
improv_serial:

wifi:
  networks:
    - ssid: peppe4
    - password: !secret wifi_password4
    - ssid: peppe2
    - password: !secret wifi_password2
    - ssid: peppe1
    - password: !secret wifi_password1
  manual_ip:
    static_ip: 192.168.1.79
    gateway: 192.168.1.1
    subnet: 255.255.255.0
    dns1: 192.168.1.1
##############################################################
  reboot_timeout: 0s  # Impedisce il riavvio automatico dopo disconnessione dopo 15 minuti...

  ap:
    ssid: "apriporte-wiegand"
    password: "3498692081"
##############################################################

captive_portal:
 
#########################################################################

web_server:
  #ota: false  # Puoi anche disabilitare l'OTA se non vuoi usarlo dalla pagina web di ESPHome
  version: 3
  auth:
    username: !secret web_server_username
    password: !secret web_server_password

#########################################################################
external_components:
  - source:
      type: local
      path: ./components
    components: [uptime_custom]
#########################################################################

text_sensor:
  - platform: uptime_custom
    name: "Uptime: "
    update_interval: 5s

  - platform: wifi_info
    ssid:
      name: "wifi connesso a:"
      web_server:
        sorting_weight: 70


#############################
 
  - platform: template
    name: "Badge Autorizzati"
    id: homeassistant_tag_scanned
    icon: mdi:badge-account
    web_server:
      sorting_weight: 20
    lambda: |-
      std::string raw = id(badge_autorizzati_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Password autorizzate"
    id: keypad_codes_sensor
    icon: mdi:form-textbox-password
    web_server:
      sorting_weight: 21
    lambda: |-
      std::string raw = id(password_autorizzate_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Impronte autorizzate"
    id: fingerprint_scanned_sensor
    icon: mdi:fingerprint
    web_server:
      sorting_weight: 22
    lambda: |-
      std::string raw = id(impronte_autorizzate_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Password Non Autorizzate"
    id: unauthorized_keypad_codes_sensor
    icon: mdi:form-textbox-password
    web_server:
      sorting_weight: 23
    lambda: |-
      std::string raw = id(unauthorized_keypad_codes_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Badge/Finger non autorizzati"
    id: unauthorized_tags_sensor
    icon: mdi:account-off
    web_server:
      sorting_weight: 24
    lambda: |-
      std::string raw = id(badge_non_autorizzati_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Buzzer Citofono"
    id: citofono_log
    icon: mdi:clipboard-text
    web_server:
      sorting_weight: 54
    lambda: |-
      std::string raw = id(citofono_log_storage);
      size_t i = 0;
      while ((i = raw.find("(", i)) != std::string::npos) {
        if (i + 11 < raw.size() && raw[i+11] == ')') {
          std::string code = raw.substr(i+1, 10);
          if (std::all_of(code.begin(), code.end(), ::isdigit)) {
            std::string gg = code.substr(0,2);
            std::string mm = code.substr(2,2);
            std::string hh = code.substr(4,2);
            std::string mi = code.substr(6,2);
            std::string ss = code.substr(8,2);
            std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
            raw.replace(i+1, 10, formatted);
            i += formatted.length();
          } else {
            i++;
          }
        } else {
          i++;
        }
      }
      size_t pos = 0;
      while ((pos = raw.find(",", pos)) != std::string::npos) {
        raw.replace(pos, 1, ",\n");
        pos += 2;
      }
      return raw;
    update_interval: 2s


#############################
 
  - platform: template
    name: "Ultima Password non valida"
    id: last_unauthorized_keypad_code_sensor
    icon: mdi:lock-alert
    web_server:
      sorting_weight: 50
    lambda: |-
      std::string raw = id(last_bad_password_storage);
      size_t start = raw.find("(");
      size_t end = raw.find(")", start);
      if (start != std::string::npos && end != std::string::npos && end - start == 11) {
        std::string code = raw.substr(start + 1, 10);
        if (std::all_of(code.begin(), code.end(), ::isdigit)) {
          std::string gg = code.substr(0, 2);
          std::string mm = code.substr(2, 2);
          std::string hh = code.substr(4, 2);
          std::string mi = code.substr(6, 2);
          std::string ss = code.substr(8, 2);
          std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
          raw.replace(start + 1, 10, formatted);
        }
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Ultimo TAG non valido"
    id: last_unauthorized_tag_code_sensor
    icon: mdi:fingerprint-off
    web_server:
      sorting_weight: 51
    lambda: |-
      std::string raw = id(last_bad_tag_storage);
      size_t start = raw.find("(");
      size_t end = raw.find(")", start);
      if (start != std::string::npos && end != std::string::npos && end - start == 11) {
        std::string code = raw.substr(start + 1, 10);
        if (std::all_of(code.begin(), code.end(), ::isdigit)) {
          std::string gg = code.substr(0, 2);
          std::string mm = code.substr(2, 2);
          std::string hh = code.substr(4, 2);
          std::string mi = code.substr(6, 2);
          std::string ss = code.substr(8, 2);
          std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
          raw.replace(start + 1, 10, formatted);
        }
      }
      return raw;
    update_interval: 2s

  - platform: template
    name: "Ultimo accesso"
    id: user_name_sensor
    icon: mdi:account
    web_server:
      sorting_weight: 52
    lambda: |-
      std::string raw = id(last_user_access_storage);
      size_t start = raw.find("(");
      size_t end = raw.find(")", start);
      if (start != std::string::npos && end != std::string::npos && end - start == 11) {
        std::string code = raw.substr(start + 1, 10);
        if (std::all_of(code.begin(), code.end(), ::isdigit)) {
          std::string gg = code.substr(0, 2);
          std::string mm = code.substr(2, 2);
          std::string hh = code.substr(4, 2);
          std::string mi = code.substr(6, 2);
          std::string ss = code.substr(8, 2);
          std::string formatted = gg + "." + mm + "-" + hh + ":" + mi + ":" + ss;
          raw.replace(start + 1, 10, formatted);
        }
      }
      return raw;
    update_interval: 2s
    
#############################

  - platform: template
    id: user_name_sensor2
    name: "User Name2"
    internal: True
    web_server:
      sorting_weight: 53




  - platform: template
    internal: True
    name: "Tag Riconosciuto"
    id: tag_name
  
  - platform: template
    name: "Time:"
    internal: true
    id: formatted_counter_sensor
    lambda: |-
      auto now = id(sntp_time).now();
      if (!now.is_valid()) return std::string("NO TIME");
      char buffer[20];
      snprintf(buffer, sizeof(buffer), "%02d%02d%02d%02d%02d",
               now.day_of_month, now.month, now.hour, now.minute, now.second);
      return std::string(buffer);
    update_interval: 1s
    icon: "mdi:numeric"



#########################################################################
 

  - platform: homeassistant
    id: citofono_visitatore
    entity_id: binary_sensor.citofono_visitatore
    on_value:
      then:
      - if:
          condition:
            lambda: 'return x == "on";'
          then:
            - lambda: |-
                // Ottieni il tempo sincronizzato con SNTP
                auto now = id(sntp_time).now();
                char timestamp[20];
                snprintf(timestamp, sizeof(timestamp), "%02d.%02d-%02d:%02d:%02d",
                         now.day_of_month, now.month,
                         now.hour, now.minute, now.second);

                // Se la dimensione del buffer è > 7, rimuovi la voce più vecchia
                if (id(citofono_log_buffer).size() > 7) {
                  id(citofono_log_buffer).erase(id(citofono_log_buffer).begin());
                }

                // Aggiungi nuova voce timestamp
                id(citofono_log_buffer).push_back(std::string(timestamp));

                // Ricostruisci la stringa del log, con separatore virgola
                std::string log;
                for (const auto& entry : id(citofono_log_buffer)) {
                  log += entry + ",";
                }

                // Rimuovi l'ultima virgola se presente
                if (!log.empty()) log.erase(log.size() - 1);

                // Pubblica lo stato aggiornato al sensore testuale
                id(citofono_log).publish_state(log);

                // Aggiorna la variabile persistente
                id(citofono_log_storage) = log;

                // Esegui lo script di salvataggio (se presente)
                id(save_citofono_log)->execute();

#########################################################################

time:
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Rome"  # Imposta la tua zona oraria
    servers:
      - "0.pool.ntp.org"
      - "1.pool.ntp.org"
      - "2.pool.ntp.org"
    update_interval: 1h  # Sincronizza ogni minuto
  
 

sensor:
  - platform: wifi_signal
    name: "Segnale WiFi"
    web_server:
      sorting_weight: 80
    update_interval: 10s

  - platform: uptime
    name: "Uptime"
    internal: true
    id: uptimex
    update_interval: 5s
# Usa un output GPIO con id "led_builtin"
 
binary_sensor:
  - platform: template
    name: "Apertura Valida"
    id: apertura_valida_sensor
    icon: mdi:lock-open-variant
    web_server:
      sorting_weight: 1
    lambda: |-
      return id(apertura_valida);
    on_press:
      then:
        - delay: 3000ms
        - globals.set:
            id: apertura_valida
            value: 'false'
  - platform: gpio
    pin:
      number: GPIO36
      mode: INPUT_PULLUP
    id: tamper_gpio
    name: pin tamper
    internal: true
    filters:
      - delayed_on: 100ms   # Filtra i falsi positivi quando il tamper è attivato
      - delayed_off: 100ms  # Filtra i falsi positivi quando il tamper è disattivato
    on_press:
      then:
        - lambda: |-
            id(tamper_state) = true;
            id(tamper_output).publish_state(true);
    on_release:  # Tamper OK (collegato = LOW)
      then:
        - lambda: |-
            // NON fare nulla quando è OK
            ESP_LOGD("tamper", "Tamper OK");


  - platform: template
    name: "Allarme Tamper"
    id: tamper_output
    device_class: safety
    #icon: "mdi:alert-octagon-outline"
    icon: mdi:lock
    web_server:
      sorting_weight: 2
    lambda: |-
      return id(tamper_state);





####################################################################
  - platform: gpio
    pin:
      number: GPIO40
      inverted: true
      allow_other_uses: true
    name: "Pin D0"
    internal: true
    id: shared_d0
  - platform: gpio
    pin:
      number: GPIO39
      inverted: true
      allow_other_uses: true
    name: "Pin D1"
    internal: true
    id: shared_d1
    
  - platform: template
    name: "Allarme segnale Wiegand"
    icon: mdi:signal-off
    web_server:
      sorting_weight: 3
    lambda: |-
      return id(shared_d0).state || id(shared_d1).state;
    filters:
      - delayed_on: 3s
      - delayed_off: 1s 
    on_press:
      then:
        - lambda: |-
            id(tamper_state) = true;
            id(tamper_output).publish_state(true);


  - platform: template
    name: "Ricezione dati..."
    id: ricezione_dati
    lambda: |-
      return id(ricezione_dati_flag);
    icon: mdi:check-network-outline
    web_server:
      sorting_weight: 4
######################################################################
  - platform: status
    name: "Stato ESP"
######################################################################





globals:
  - id: ricezione_dati_flag
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: apertura_valida
    type: bool
    initial_value: 'false'  # Inizialmente il codice non è valido


  - id: last_formatted_code
    type: std::string
    initial_value: ""


  - id: fingerprint_history
    type: std::vector<std::string>
    initial_value: ""

  - id: keypad_code_history
    type: std::vector<std::string>
    initial_value: ""
  
  - id: tag_history
    type: std::vector<std::string>
    initial_value: ""
 

  # Aggiunta lista di password non autorizzate
  - id: unauthorized_keypad_codes
    type: std::vector<std::string>
    initial_value: ""



  # Aggiunta lista di badge non autorizzati
  - id: unauthorized_tags
    type: std::vector<std::string>
    initial_value: ""
  
  - id: last_tag
    type: uint64_t
    restore_value: True
    initial_value: '0'  # L'ultimo tag letto sarà un numero
 
  - id: led_state
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: tamper_state
    type: bool
    restore_value: true
    initial_value: 'false'
##########################################à
  - id: citofono_log_string
    type: std::string
    restore_value: true
    initial_value: "\"\""

  - id: citofono_log_buffer
    type: std::vector<std::string>
    restore_value: false
    initial_value: 'std::vector<std::string>()'

  - id: wifi_disconnected_minutes
    type: int
    restore_value: no
    initial_value: '0'




  - id: badge_autorizzati_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: password_autorizzate_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: impronte_autorizzate_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: unauthorized_keypad_codes_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: badge_non_autorizzati_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: citofono_log_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: last_bad_password_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: last_bad_tag_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""

  - id: last_user_access_storage
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: ""
#######################################################
output:
  - platform: ledc
    pin: GPIO18
    id: led_builtin
    frequency: 1000 Hz


interval:
  - interval: 2s
    then:
      - lambda: |-
          static bool led_state = false;
          led_state = !led_state;
          if (led_state) {
            id(led_builtin).set_level(1.0);   
          } else {
            id(led_builtin).set_level(0.0);  // spento
          }

  - interval: 60s
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - if:
                condition:
                  lambda: 'return id(wifi_disconnected_minutes) > 0;'
                then:
                  - logger.log: "WiFi riconnesso, azzero il contatore."
                  - lambda: 'id(wifi_disconnected_minutes) = 0;'
          else:
            - lambda: 'id(wifi_disconnected_minutes) += 1;'
            - logger.log: "WiFi disconnesso da ${wifi_disconnected_minutes} minuti."
            - if:
                condition:
                  lambda: 'return id(wifi_disconnected_minutes) >= 3;'
                then:
                  - logger.log: "WiFi disconnesso da 3 minuti. Provo riconnessione..."
                  - script.execute: wifi_reconnect_script
                  - lambda: 'id(wifi_disconnected_minutes) = 0;'



 
#######################################################
switch:
  - platform: template
    internal: false
    restore_mode: ALWAYS_OFF 
    name: "portone cancello"
    icon: mdi:door
    web_server:
      sorting_weight: 10
    id: portone_cancello
    optimistic: true
    lambda: return id(portone_cancello).state;  
    on_turn_on: 
      then:
        - delay: 4s
        - switch.turn_off: portone_cancello


  - platform: template
    internal: false
    restore_mode: ALWAYS_OFF
    name: "spesa da prendere"
    icon: "mdi:shopping-cart"
    web_server:
      sorting_weight: 9
    id: spesa_da_prendere
    optimistic: true
    lambda: return id(spesa_da_prendere).state;  
    on_turn_on: 
      then:
        - delay: 1s
        - switch.turn_off: spesa_da_prendere


  - platform: gpio
    id: relay1
    pin: 
      number: GPIO37
      inverted: true
      mode: 
        output: True
        open_drain: True
    restore_mode: ALWAYS_OFF
    name: "Apri Portone"
    web_server:
      sorting_weight: 6
    icon: mdi:garage-open
    on_turn_on:
      - globals.set:
          id: apertura_valida
          value: 'true'
      - delay: 1000ms
      - switch.turn_off: relay1  # Spegne il relè dopo 1000ms

  - platform: gpio
    id: relay2
    pin: 
      number: GPIO38
      inverted: true
      mode: 
        output: True
        open_drain: True
    restore_mode: ALWAYS_OFF
    name: "Apri Cancello"
    web_server:
      sorting_weight: 7
    icon: mdi:gate
    on_turn_on:
      - globals.set:
          id: apertura_valida
          value: 'true'
      - delay: 1000ms
      - switch.turn_off: relay2  # Spegne il relè dopo 1000ms

  - platform: template
    id: tag_scan_enabled
    name: "Abilita Tastiera"
    web_server:
      sorting_weight: 5
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:keyboard

  - platform: template
    id: clear_history_button
    name: "Cancella Storico"
    web_server:
      sorting_weight: 11
    icon: mdi:history
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          // Svuoto le liste e le variabili di stato
          id(unauthorized_tags).clear();
          id(unauthorized_keypad_codes).clear();
          id(tag_history).clear();
          id(fingerprint_history).clear();
          id(keypad_code_history).clear();

          // Pulisco le variabili di appoggio/storage temporanee
          id(citofono_log_string) = "";
          id(citofono_log_buffer).clear();

          // Pulizia storage persistenti (globals)
          id(badge_autorizzati_storage) = "";
          id(password_autorizzate_storage) = "";
          id(impronte_autorizzate_storage) = "";
          id(unauthorized_keypad_codes_storage) = "";
          id(badge_non_autorizzati_storage) = "";
          id(citofono_log_storage) = ""; // << AGGIUNTO

          id(last_bad_password_storage) = "";
          id(last_bad_tag_storage) = "";
          id(last_user_access_storage) = "";

          // Pubblica stato vuoto su tutti i text_sensor coinvolti
          id(homeassistant_tag_scanned).publish_state("");
          id(keypad_codes_sensor).publish_state("");             // << AGGIUNTO
          id(fingerprint_scanned_sensor).publish_state("");      // << AGGIUNTO
          id(unauthorized_keypad_codes_sensor).publish_state(""); // << AGGIUNTO
          id(unauthorized_tags_sensor).publish_state("");        // << AGGIUNTO
          id(citofono_log).publish_state("");

          id(last_unauthorized_keypad_code_sensor).publish_state(id(last_bad_password_storage));
          id(last_unauthorized_tag_code_sensor).publish_state(id(last_bad_tag_storage));
          id(user_name_sensor).publish_state(id(last_user_access_storage));

      - script.execute: save_all
      - delay: 500ms
      - switch.turn_off: clear_history_button



 ##########################################################################################################################
  - platform: template
    id: resetta_tamper
    name: "Reset Tamper"
    icon: mdi:restart
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - switch.template.publish:
          id: resetta_tamper
          state: ON
      - delay: 100ms  # breve pausa per permettere alla UI di ricevere l'ON
      - lambda: |-
          id(tamper_state) = false;
          id(tamper_output).publish_state(false);
      - delay: 500ms
      - switch.template.publish:
          id: resetta_tamper
          state: OFF
##########################################################################################################################


key_collector:
  - id: pincode_reader
    source_id: mykeypad
    min_length: 6
    max_length: 9
    end_keys: "#"
    end_key_required: true
    clear_keys: "*"
    allowed_keys: "0123456789"
    timeout: 5s
    on_result:
      then:
        - globals.set:
            id: ricezione_dati_flag
            value: 'true'
        - delay: 100ms
        - lambda: |-
            std::string code = x;
            id(last_formatted_code) = code;
            std::string user_name = "Unknown";
            bool codice_valido = false;
            int relay = 0;

            //////////////////////////////////////////////////////////////////
            // Mappa dei codici validi e relativa azione (relay)
            std::map<std::string, std::pair<std::string, int>> codici_validi = {
              {"19751983", {"Pwd.GLOBALE",    12}},
              {"19758383", {"Pwd.PORTONE",    1}},
              {"19757575", {"Pwd.CANCELLO",     2}}
            };
            //////////////////////////////////////////////////////////////////

            auto it = codici_validi.find(code);
            std::string timestamp = id(formatted_counter_sensor).state;

            if (it != codici_validi.end()) {
              id(apertura_valida) = true;
              codice_valido = true;
              user_name = it->second.first;
              relay = it->second.second;
              id(user_name_sensor2)->publish_state(user_name);

              ESP_LOGI("ACCESSO", "Password VALIDA: %s", user_name.c_str());

              std::string voce = user_name + "-(" + timestamp + ")";
              id(user_name_sensor)->publish_state(voce);
              id(save_last_records)->execute();
              id(last_user_access_storage) = voce;

              // 🔽 Salva nel global persistente e aggiorna text_sensor
              id(save_authorized_keypad_codes)->execute();
            } else {
              codice_valido = false;
              ESP_LOGW("ACCESSO", "Password NON valida: %s", code.c_str());

              std::string voce_errata = code + "-(" + timestamp + ")";
              id(user_name_sensor2)->publish_state(code);
              id(last_unauthorized_keypad_code_sensor)->publish_state(voce_errata);
              id(save_last_records)->execute();


              id(last_bad_password_storage) = voce_errata;

              // 🔽 Salva nel global persistente e aggiorna text_sensor
              id(save_unauthorized_keypad_codes)->execute();
            }

            // Attiva relè solo se tastiera abilitata
            if (id(tag_scan_enabled).state) {
              if (id(tamper_state)) {
                ESP_LOGW("TAMPER", "Tastiera DISABILITATA! TAMPER IN ALLARME!");
              } else if (codice_valido) {
                if (relay == 1 && !id(accensione_relay1)->is_running())
                  id(accensione_relay1)->execute();
                else if (relay == 2 && !id(accensione_relay2)->is_running())
                  id(accensione_relay2)->execute();
                else if (relay == 12 && !id(accensione_relay12)->is_running())
                  id(accensione_relay12)->execute();
              }
            } else {
              ESP_LOGI("KEYPAD", "Tastiera DISABILITATA");
            }
        - script.execute: stop_ricezione_dati
        - homeassistant.tag_scanned: !lambda 'return id(user_name_sensor2).state.c_str();'

######################################################
#external_components:
#  - source: 
#      type: local
#      path: ./components
#    components: [mywiegand]
######################################################




wiegand:
  ######################################################
  #mywiegand:
  ######################################################
  id: mykeypad
  d0:
    number: GPIO40
    allow_other_uses: true
  d1:
    number: GPIO39
    allow_other_uses: true
  ######################################################
  ###lockout_time: 5000ms
  ######################################################
  on_tag:
    - globals.set:
        id: ricezione_dati_flag
        value: 'true'
    - delay: 100ms
    - lambda: |-
        uint64_t tag = std::stoull(x.c_str());
        std::string name = "Unknown";
        std::string timestamp = id(formatted_counter_sensor)->state.c_str();
        bool autorizzato = false;
        int relay = 0;

        // === Mappe impronte ===
        std::map<uint64_t, std::pair<std::string, int>> impronte = {
          {286327041, {"Imp.Giuseppe1",   12}},
          {286326785, {"Imp.Giuseppe2",   12}},
          {286327553, {"Imp.Giuseppe3",   12}},
          {286327297, {"Imp.Giuseppe4",   12}},
          {286327809, {"Imp.Desy1",       12}},
          {286328321, {"Imp.Desy2",       12}},
          {286328065, {"Imp.Desy3",       12}},
          {286328577, {"Imp.Desy4",       12}},
          {286329345, {"Imp.Maria1",      12}},
          {286329601, {"Imp.Maria2",      12}}
        };

        // === Mappe badge ===
        std::map<uint64_t, std::pair<std::string, int>> badge = {
          {509791345,  {"Badge.Maria",    12}},
          {854418574,  {"Badge.Desiree",  12}},
          {851971486,  {"Badge.Giuseppe", 12}},
          {2910431538, {"Badge.ATe",      12}}
        };

        // Verifica impronta
        if (impronte.count(tag)) {
          id(apertura_valida)=true;
          name = impronte[tag].first;
          relay = impronte[tag].second;
          autorizzato = true;
          std::string combined = name + "-(" + timestamp + ")";
          id(user_name_sensor)->publish_state(combined);
          id(save_last_records)->execute();
          ESP_LOGI("ACCESSO", "Impronta riconosciuta: %s", name.c_str());
          id(tag_name)->publish_state(name);

          id(fingerprint_history).push_back(combined);
          if (id(fingerprint_history).size() > 7)
            id(fingerprint_history).erase(id(fingerprint_history).begin());

          std::string history;
          for (size_t i = 0; i < id(fingerprint_history).size(); ++i) {
            history += id(fingerprint_history)[i];
            if (i < id(fingerprint_history).size() - 1) {
              history += ",";
            }
          }
          id(fingerprint_scanned_sensor)->publish_state(history);

          // Salvataggio persistente impronte autorizzate
          id(impronte_autorizzate_storage) = history;
          id(save_valid_fingerprint_history)->execute();

        } 
        // Verifica badge
        else if (badge.count(tag)) {
          name = badge[tag].first;
          relay = badge[tag].second;
          id(apertura_valida)=true;
          autorizzato = true;
          std::string combined = name + "-(" + timestamp + ")";
          id(user_name_sensor)->publish_state(combined);
          id(save_last_records)->execute();
          ESP_LOGI("ACCESSO", "Badge riconosciuto: %s", name.c_str());
          id(tag_name)->publish_state(name);

          id(tag_history).push_back(combined);
          if (id(tag_history).size() > 7)
            id(tag_history).erase(id(tag_history).begin());

          std::string tag_history_str;
          for (size_t i = 0; i < id(tag_history).size(); ++i) {
            tag_history_str += id(tag_history)[i];
            if (i < id(tag_history).size() - 1) {
              tag_history_str += ",";
            }
          }
          id(homeassistant_tag_scanned)->publish_state(tag_history_str);

          // Salvataggio persistente badge autorizzati
          id(badge_autorizzati_storage) = tag_history_str;
          id(save_valid_tag_history)->execute();

        } 
        // Non autorizzato
        else {
          autorizzato = false;
          ESP_LOGI("ACCESSO", "Tag NON autorizzato: %s", x.c_str());
          std::string combined = x + "-(" + timestamp + ")";
          id(user_name_sensor2)->publish_state(x);
          id(unauthorized_tags).push_back(combined);
          if (id(unauthorized_tags).size() > 7)
            id(unauthorized_tags).erase(id(unauthorized_tags).begin());

          std::string unauthorized_tags_str;
          for (size_t i = 0; i < id(unauthorized_tags).size(); ++i) {
            unauthorized_tags_str += id(unauthorized_tags)[i];
            if (i < id(unauthorized_tags).size() - 1) {
              unauthorized_tags_str += ",";
            }
          }
          id(unauthorized_tags_sensor)->publish_state(unauthorized_tags_str);
          id(last_unauthorized_tag_code_sensor)->publish_state(combined);
          id(save_last_records)->execute();

          // Salvataggio persistente tag non autorizzati
          id(badge_non_autorizzati_storage) = unauthorized_tags_str;
          id(last_bad_tag_storage) = combined;
          id(save_unauthorized_tag_history)->execute();
        }

        if (id(tag_scan_enabled).state) {
          if (id(tamper_state)) {
            ESP_LOGW("TAMPER", "Tastiera DISABILITATA!!! TAMPER IN ALLARME!!!");
          } else if (autorizzato) {
            if (relay == 1 && !id(accensione_relay1)->is_running())
              id(accensione_relay1)->execute();
            else if (relay == 2 && !id(accensione_relay2)->is_running())
              id(accensione_relay2)->execute();
            else if (relay == 12 && !id(accensione_relay12)->is_running())
              id(accensione_relay12)->execute();
          }
        } else {
          ESP_LOGI("TAG", "Tastiera DISABILITATA");
        }

    - script.execute: stop_ricezione_dati
    - homeassistant.tag_scanned: !lambda 'return id(tag_name).state.c_str();'


script:
  - id: accensione_relay12
    then:
      - script.execute: accensione_relay2 # cancello
      - delay: 2000ms
      - script.execute: accensione_relay1 # portone
      - delay: 3000ms # pausa di 3 secondi tra 2 aperture...

  - id: accensione_relay1 # apri portone
    then:
      - switch.turn_on: relay1
      - delay: 2000ms

  - id: accensione_relay2 # apri cancello
    then:
      - switch.turn_on: relay2
      - delay: 2000ms
 
  - id: wifi_reconnect_script
    then:
      - lambda: 'WiFi.disconnect();'
      - delay: 2s
      - lambda: 'WiFi.begin();'


 
#########################################################

  - id: save_authorized_keypad_codes
    then:
      - lambda: |-
          std::string voice = id(user_name_sensor).state ;
          if (!id(password_autorizzate_storage).empty()) {
            id(password_autorizzate_storage) += "," + voice;
          } else {
            id(password_autorizzate_storage) = voice;
          }

          while (id(password_autorizzate_storage).length() > 254) {
            size_t pos = id(password_autorizzate_storage).find(',');
            if (pos == std::string::npos) break;
            id(password_autorizzate_storage).erase(0, pos + 1);
          }

          id(keypad_codes_sensor)->publish_state(id(password_autorizzate_storage));

  - id: save_citofono_log
    then:
      - lambda: |-
          std::string log;
          for (const auto& entry : id(citofono_log_buffer)) {
            log += entry + ",";
          }
          if (!log.empty()) log.pop_back();

          while (log.length() > 254) {
            size_t pos = log.find(',');
            if (pos == std::string::npos) break;
            log.erase(0, pos + 1);
          }

          id(citofono_log_storage) = log;

  - id: save_unauthorized_keypad_codes
    then:
      - lambda: |-
          std::string voice = id(last_unauthorized_keypad_code_sensor).state;
          if (!id(unauthorized_keypad_codes_storage).empty()) {
            id(unauthorized_keypad_codes_storage) += "," + voice;
          } else {
            id(unauthorized_keypad_codes_storage) = voice;
          }

          while (id(unauthorized_keypad_codes_storage).length() > 254) {
            size_t pos = id(unauthorized_keypad_codes_storage).find(',');
            if (pos == std::string::npos) break;
            id(unauthorized_keypad_codes_storage).erase(0, pos + 1);
          }

          id(unauthorized_keypad_codes_sensor)->publish_state(id(unauthorized_keypad_codes_storage));

  - id: save_unauthorized_tag_history
    then:
      - lambda: |-
          std::string buffer;
          for (const auto& entry : id(unauthorized_tags)) {
            buffer += entry + ",";
          }
          if (!buffer.empty()) buffer.pop_back();

          while (buffer.length() > 254) {
            size_t pos = buffer.find(',');
            if (pos == std::string::npos) break;
            buffer.erase(0, pos + 1);
          }

          id(badge_non_autorizzati_storage) = buffer;

  - id: save_valid_fingerprint_history
    then:
      - lambda: |-
          std::string buffer;
          for (const auto& entry : id(fingerprint_history)) {
            buffer += entry + ",";
          }
          if (!buffer.empty()) buffer.pop_back();

          while (buffer.length() > 254) {
            size_t pos = buffer.find(',');
            if (pos == std::string::npos) break;
            buffer.erase(0, pos + 1);
          }

          id(impronte_autorizzate_storage) = buffer;

  - id: save_valid_tag_history
    then:
      - lambda: |-
          std::string buffer;
          for (const auto& entry : id(tag_history)) {
            buffer += entry + ",";
          }
          if (!buffer.empty()) buffer.pop_back();

          while (buffer.length() > 254) {
            size_t pos = buffer.find(',');
            if (pos == std::string::npos) break;
            buffer.erase(0, pos + 1);
          }

          id(badge_autorizzati_storage) = buffer;

#########################################################
  - id: restore_authorized_keypad_codes
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(keypad_codes_sensor)->publish_state(id(password_autorizzate_storage));

  - id: restore_citofono_log
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(citofono_log_buffer).clear();
          std::string saved_log = id(citofono_log_storage);
          size_t start = 0;
          while (true) {
            size_t end = saved_log.find(',', start);
            std::string token;
            if (end == std::string::npos) {
              token = saved_log.substr(start);
            } else {
              token = saved_log.substr(start, end - start);
            }
            trim(token);
            if (!token.empty()) {
              id(citofono_log_buffer).push_back(token);
            }
            if (end == std::string::npos) break;
            start = end + 1;
          }

          std::string log;
          for (const auto& entry : id(citofono_log_buffer)) {
            log += entry + ",";
          }
          if (!log.empty()) log.erase(log.size() - 1);
          id(citofono_log)->publish_state(log);

  - id: restore_unauthorized_keypad_codes
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(unauthorized_keypad_codes).clear();
          std::string data = id(unauthorized_keypad_codes_storage);
          size_t start = 0;
          while (true) {
            size_t end = data.find(',', start);
            std::string item;
            if (end == std::string::npos) {
              item = data.substr(start);
            } else {
              item = data.substr(start, end - start);
            }
            trim(item);
            if (!item.empty()) {
              id(unauthorized_keypad_codes).push_back(item);
            }
            if (end == std::string::npos) break;
            start = end + 1;
          }
          std::string log;
          for (const auto& entry : id(unauthorized_keypad_codes)) {
            log += entry + ",";
          }
          if (!log.empty()) log.erase(log.size() - 1);
          id(unauthorized_keypad_codes_sensor)->publish_state(log);

  - id: restore_unauthorized_tag_history
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(unauthorized_tags).clear();
          std::string data = id(badge_non_autorizzati_storage);
          size_t start = 0;
          while (true) {
            size_t end = data.find(',', start);
            std::string item;
            if (end == std::string::npos) {
              item = data.substr(start);
            } else {
              item = data.substr(start, end - start);
            }
            trim(item);
            if (!item.empty()) {
              id(unauthorized_tags).push_back(item);
            }
            if (end == std::string::npos) break;
            start = end + 1;
          }
          std::string log;
          for (const auto& entry : id(unauthorized_tags)) {
            log += entry + ",";
          }
          if (!log.empty()) log.erase(log.size() - 1);
          id(unauthorized_tags_sensor)->publish_state(log);

  - id: restore_valid_fingerprint_history
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(fingerprint_history).clear();
          std::string data = id(impronte_autorizzate_storage);
          size_t start = 0;
          while (true) {
            size_t end = data.find(',', start);
            std::string item;
            if (end == std::string::npos) {
              item = data.substr(start);
            } else {
              item = data.substr(start, end - start);
            }
            trim(item);
            if (!item.empty()) {
              id(fingerprint_history).push_back(item);
            }
            if (end == std::string::npos) break;
            start = end + 1;
          }
          std::string log;
          for (const auto& entry : id(fingerprint_history)) {
            log += entry + ",";
          }
          if (!log.empty()) log.erase(log.size() - 1);
          id(fingerprint_scanned_sensor)->publish_state(log);

  - id: restore_valid_tag_history
    then:
      - lambda: |-
          auto trim = [](std::string &s) {
            while (!s.empty() && (s.front() == ' ' || s.front() == '\t')) s.erase(0, 1);
            while (!s.empty() && (s.back() == ' ' || s.back() == '\t')) s.pop_back();
          };

          id(tag_history).clear();
          std::string data = id(badge_autorizzati_storage);
          size_t start = 0;
          while (true) {
            size_t end = data.find(',', start);
            std::string item;
            if (end == std::string::npos) {
              item = data.substr(start);
            } else {
              item = data.substr(start, end - start);
            }
            trim(item);
            if (!item.empty()) {
              id(tag_history).push_back(item);
            }
            if (end == std::string::npos) break;
            start = end + 1;
          }
          std::string log;
          for (const auto& entry : id(tag_history)) {
            log += entry + ",";
          }
          if (!log.empty()) log.erase(log.size() - 1);
          id(homeassistant_tag_scanned)->publish_state(log);

##################################################
  - id: save_last_records
    then:
      - lambda: |-
          id(last_bad_password_storage) = id(last_unauthorized_keypad_code_sensor).state;
          id(last_bad_tag_storage) = id(last_unauthorized_tag_code_sensor).state;
          id(last_user_access_storage) = id(user_name_sensor).state;
  - id: restore_last_records
    then:
      - lambda: |-
          id(last_unauthorized_keypad_code_sensor).publish_state(id(last_bad_password_storage));
          id(last_unauthorized_tag_code_sensor).publish_state(id(last_bad_tag_storage));
          id(user_name_sensor).publish_state(id(last_user_access_storage));


  - id: restore_all
    then: 
      - script.execute: restore_unauthorized_keypad_codes
      - script.execute: restore_authorized_keypad_codes
      - script.execute: restore_valid_tag_history
      - script.execute: restore_valid_fingerprint_history
      - script.execute: restore_unauthorized_tag_history
      - script.execute: restore_citofono_log
      - script.execute: restore_last_records


  - id: save_all
    then: 
      - script.execute: save_authorized_keypad_codes
      - script.execute: save_valid_tag_history
      - script.execute: save_valid_fingerprint_history
      - script.execute: save_unauthorized_tag_history
      - script.execute: save_unauthorized_keypad_codes
      - script.execute: save_citofono_log
      - script.execute: save_last_records

  - id: stop_ricezione_dati
    then:
      - delay: 5s
      - lambda: |-
          id(ricezione_dati_flag) = false;
	  
	  
